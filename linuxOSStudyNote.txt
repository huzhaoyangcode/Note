运维专题成文计划：
1、听马哥视频，作笔记
2、复习并成文，成框架
3、写专题。


第一课：计算机操作系统基础
日期：2018年1月9日
计算机系统上下层结构

		应用程序：在一个系统上开发应用程序的时候，可以直接调用内核
		的功能（系统调用）进行开发，也可以调用API进行开发。使用系统
		调用速度比较快，使用库比较方便开发。
		------------------------------------------------
	    库（lib）：本身是一种了应用程序，但是其没有程序入口，只能
		被调用。又称为API(Application program interface),
		应用程序编程接口。是对系统调用的再一次封装，方便应用程序的
		开发。有了库，程序员就不用使用最底层的系统调用接口来开发一
		些大家都经常使用的接口了，可以调用库进行开发。这就意味着库
		在系统中又抽象出来了一层，当应用程序建立在库上进行开发时候，
		如果使用的库调用在不同的系统上接口一致，那么该应用程序就可
		以在这两个操作系统上进行移植。
	   -------------------------------------------------
		内核：程序的协调器，硬件管理器，虚拟器。 
		以系统调用（system call）的方式向上提供使用硬件的接口。
		并不提供特定的任务，只做硬件抽象。
	   -------------------------------------------------
		硬件：核心设备（cpu, 存储器设备）,  外围设备（IO设备）
		设备之间使用总线进行互相连接。

日期：2019年1月14日
系统上的应用程序分为服务性程序和交互式程序。服务性程序一般是随系统的启动而启动，并且运行在后台。

内核和应用程序都运行在内存上，为了保护内核，应用程序是不能访问内核空间的，CPU会有保护级别的。

当系统启动起来之后内存的分布：BIOS+kernelSpace+userspace应用程序空间。

shell程序是操作系统必须的一个应用程序，用来理解用户输入命令，并解析传递给内核，并把内核的运算结果返回显示。
shell 程序有GUI(图形用户界面)和CLI(command line interface)。他们都是应用程序。
linux常见的GUI(Graphic User interface):gnome, xface, KDE.
gnome:c
xface:简洁的嵌入式
KDE:C++
linux常用的CLI:bashshell cshell....
在此接口启动的程序和此接口有很大的关系。

内核功能：进程管理，内存管理，提供文件系统，网络功能，硬件驱动，安全机制等等。由此可见，内核是一个通用软件,是一个平台。

linux的哲学思想：
1、自由开源
2、由目的单一的小程序组成
3、一切皆文件
4、尽量避免捕获用户接口，即尽量不和用户交互
5、配置文件保存为纯文本文件
6、没有信息就是最好的信息

CLI接口：
	bash shell命令提示符：prompts(那一长串东西)
					  #:root
					  $:普通用户

命令格式：
	命令 选项 参数
		选项：修改命令的执行方式，可以多个一起使用，有长选项和短选项之分。选项也可能带参数。
		参数：命令的作用对象，多个参数要用空格进行隔开。

切换终端：ctrl + alt + f1...f7
其中f7为图形界面，但是第一次启动图形界面的时候要用startx & 启动图形界面并在后台运行。
而在图形界面上再打开的terminal程序都是模拟终端。

切换用户：
使用 su(switch user):
su [-l] username
su hu
su -l hu ：不仅切换用户，还切换用户文件夹。
退回：exit

修改密码：
passwd :修改当前用户密码

设置密码原则：
1、使用四种字符类别中至少三种
2、足够长，大于7位
3、使用随机字符串
4、定期更换
5、循环周期足够大

linux GUI称为x-window , x表示协议，常见的有gnome, xface, KDE 
CLI：command line interface : bash , Cshell....

IDE:develop environment(开发环境，集成开发环境)

window:
.dll: dynamic link library 动态链接库

linux： 
.so : shared object 共享对象，也叫动态链接对象（dso）

一个简单的linux:kernel + shell + shell所依赖的库 即可，若想用其他的功能，在安装软件和其所依赖的库即可。

日期2019年1月21日 
linux认证机制分部：
authentication：认证
authorization：授权
audit ：审计

程序的魔数（magic number）：指定二进制文件的格式，是不是可以执行，即是不是有执行入口，库就没有执行入口。例如脚本开头的#！/bin/bash

通用命令格式： command [options] [arguments]

ls  ：list 列出目录下的所有文件和目录。
    -l :长格式显示，显示文件信息。
	    显示信息说明：
		drwxr-xr-x  2 root root   60 一月 21 09:14 vfio

		第一位：linux 的文件类型：
				-:普通文件
				d:directory 目录文件
				c:character 字符设备文件
				b:block     块设备文件
				l:link      符号链接文件(symbolic link file软链接)
				p:pipe      管道文件
				s:socket    套接字文件
		九位：文件权限（mode）: r:read w:write x:execute   user group other
		文件被硬链接的次数：
		属主：
		属组：
		大小（size）:默认单位是字节（bytes）
		时间戳：timestamp:每个文件有三个时间戳，这里显示的是最近一次被修改的时间，即内容被修改的时间。
						1、访问时间access：read时间
						2、修改modify :改变的文件的内容
						3、改变change 文件包含两种数据：文件数据和属性数据（元数据meta）：此处改变的是文件的属性数据。
		文件名
	 -h :human readable 单位换算的。默认为b(字节)可以转换为M , G等等。根据大小自动转换。
	 -a :all  显示所有文件，包括以点开头的隐藏文件。.代表当前目录 .. 代表父目录
	 -A :显示所有文件，但是不显示. 和 ..
	 -d :显示目录自身属性，不是目录里面的文件。
	 -i :显示文件的索引节点号 index node : 计算机识别计算机中唯一的文件
	 -r :逆序显示文件
	 -R	:递归显示Recursion, 显示目录中的目录中的文件和目录...
	 -s :输出文件申请的空间大小
	 -S	:按文件的大小排序，最大的在最上面
		
pwd : print working directory 显示当前目录。
cd :change directory 改变目录
	不加任何参数：回到用户的家目录，等价与：cd ~ 
	cd ~username：进入指定用户的家目录
	cd -: 在前一个目录和当前目录来回切换

type: 显示指定命令的类型。
		linux 命令类型：内部命令（shell内置，内建命令，shell内置的功能）和外部命令。
			  外部命令：在文件系统下有一个与命令相同的可执行文件。
			  
变量：命名的内存空间。变量声明的过程就是申请内存空间的过程。
heap(堆):
stack（栈）:
环境变量：就是用来定义当前用户的工作环境的，相当于shell程序的配置文件。printenv查看所有环境变量。
PATH:一堆用：号隔开的路径，执行命令的时候会找，第一个找到的就用。但是不是每一次都会找，会有缓存，hash可以查看。cache is king. 缓存在计算机中真的很重要，可以用来提高效率。
SHELL：指明当前用户的shell类型

计算机时间机制：
在计算机中，晶体振荡器用来统计时间。
ntp:network time protocal
linux开机后有两个时间，系统时间和硬件时间。
date:系统时间
hwclock:硬件时间

date:获得或设置系统时间
	+%T :显示时间
	+%S :秒
	+%s :1970年01月01日 到现在的秒数，数据库一般使用这个时间的，不受时区影响。

hwclock 
	-w:--systohc 把系统时间同步到硬件时间
	-s:--hctosys 读取硬件时钟写到系统时间
	-r:--show 读取硬件时钟
	

#获得命令使用帮助
内部命令获得帮助：help+命令名
外部命令获得帮助：command --help:获得外部命令的简要信息
无论外部还是内部命令都可以用：man + 命令名
info:man的补充。历史， 链接...然而用的并不多
/usr/share/doc:说明文档位置FAQ(freequently ask and question)
google和百度

#man(mannul 手册)
用法:man + [章节] + comand
##章节说明：1、命令(/bin, /usr/bin, /usr/local/bin) 2、系统调用 3、库调用 4、特殊文件（设备文件）man 4 tty 5、文件格式（某个命令或软件配置文件格式的说明）man 5 passwd  6、games 与游戏相关的 7、不便归类的 
8、管理命令(/sbin, /usr/sbin)

##用法
[]：可选 |：多选一 <>: 必选 ...:可以多个 {}：无特殊意义
NAME:命令名称-及简要说明
SYNOPSIS:用法说明
DESCRIPTION:详细说明
FILES:此命令相关的配置文件
BUGS:bug报给谁
EXAMPLES:使用实例
SEE ALSO: 另见

/:向后搜索
？：向前搜索
n：下一个
N:前一个
b: 向前翻一屏
space:向后翻一屏幕
q:退出

思想：
1、整合资源的能力决定事业的高度。多交流。
2、只有给别人讲明白的知识才是自己的知识。
3、4W 1H what where who when why how
#whatis :显示命令的简要信息和命令在man中的章节。

linux 文件系统：倒置的树状结构，至高点为根/。
working directory == current directory
相对于/的路径为绝对路径，而相对于当前所处位置的路径为相对路径。


echo : 输出一行文本,默认带换行符
	-n: 不带最后的换行符
	-e: 启用转义字符
	-E: 关闭转义字符，默认会带这个
	
printf: 格式化输出数据，默认不带换行符,默认可以使用转义字符。

file：查看文件的类型
    file + 文件
	ELF: executable linkable file 可执行的可链接的文件，linux常用的可执行二进制文件的类型。
	PE:windows 上的可执行文件格式。

文件系统：
rootfs:linux下的根文件系统，为倒置的树状结构，叶子节点为文件，可以分叉的节点为目录。

FHS filesystem hierarchy standard : 文件系统层级化标准，为了规范所有的linux分支，所规定的文件系统的标准。
/boot: 系统启动相关的文件 如内核、initrd、 以及grub(bootloader)等
/dev:  设备文件，块设备：随机设备，可以实现随机访问的，如硬盘。 字符设备：线性设备，有次序的，按字符访问，如键盘、鼠标、显示器。
		背景黑，前景黄。没有大小，显示的是设备号，主设备号（major）和次设备号(minor)
/etc:  配置文件所存放的目录。
/home: 用户的家目录，每一个用户的家目录，在/home/username, 特殊的， root用户的家目录在/root下
/lib:  library 库文件和内核模块文件（/lib/module）,库文件有两类：静态库和动态库两种。
	   静态库:.a 直接链接到程序的地址空间，并作为程序的一部分。动态库：.so 共享库，不需要链接，作为程序的依赖，运行的时候调用就行了。
	   动态编译：
	   静态编译：
lost+found:保存断电没有来得及保存的东西。
/media:挂载点目录，用来挂载移动设备：u盘等。
/mnt:  挂载点目录，额外的临时文件系统的挂载点。
/opt:  optional 可选目录，早期用来安装第三方软件。
/proc: 伪文件系统，内核映射文件，包括内核的可调参数，统计数据等。启动之后才有文件，不启动没有文件。实际上里面不是文件，是模拟出来的。
/sys:  伪文件系统，与硬件相关的属性映射文件。
/tmp:  临时文件目录，每个用户都能存储自己的文件，但是不能删除别人的文件，/var/tmp也是临时文件目录。
/var:  可变化的文件,log, mail , run
/bin:  binary可执行文件目录，都是用户命令
/sbin: binary可执行文件目录，和管理相关的命令
/usr:  universal shared readonly/resources 全局的共享只读文件。
	   /usr/bin: 与/bin: 前者与系统启动没关系，后者和系统启动有关系。
/usr/local:第三方软件的安装目录。

文件和文件目录的命名规则：
1、文件名长度不能超过255个字符
2、不能使用/做文件名
3、严格区分大小写

ASCII:American Standard Code for Information Interchange 美国标准信息交换代码
7位二进制，可以表示128个变化，内存中最小可访问的单元是字，八位。
ASCII码表：man ASCII
文本编辑器和字处理器是不一样的，文本编辑器：只存储文本，不存储格式，而字处理器则存储了格式信息。
字符集：ASCII， unicode. GB2312


当我们要使用命令自身而不是别名的时候，用\，例如：\ls
linux命令分类：
#文件管理
touch: change file timestamps 修改文件时间戳，也可以用来创建空文件
      -c: --no-create   不存在，也不创建文件
	  -a: 只改变访问时间
	  -m: 只改变修改时间
	  -t: 指定时间,配合-a -m使用，指定要修改到的时间。
创建文件：touch, 文本编辑器。
stat:  显示文件和文件系统的状态信息
rm:    remove 删除文件
	  -i：交互式
	  -f:force 强行删除。
	  -r:recursive 递归删除，可以用来删除目录
cp:    copy file 复制文件
cp srcfile...  targetfile  只允许处理一个目的地。但是不能把多个文件复制成一个文件，可以把多个文件复制到一个目录。并且默认情况下不复制目录。
	  -r:递归复制一个目录
	  -f:force 强制复制，如果目标文件存在则覆盖。
	  -i:interactive 交互式，提示。root 用户会自动设置cp = cp -i别名，而普通用户没有。
	  -p:--preserve 复制的时候保留属主，属组，权限，时间戳等属性信息。不加此选项，谁复制的就属于谁了。
	  -a:递归，复制链接，保持文件所有属性, 用于实现备份，归档复制，保留一切属性。
	  -L:复制链接所指向的文件
	  -P:复制链接，而不是文件
	  -d:保持链接
   eg:cp /etc/{passwd,file1,file2} /tmp 支持花括号展开
   
mv: move 移动文件,移动目录的时候不需要加任何选项,并且不能把目录复制成一个文件。不存在可以发生重命名。可以用来重命名和移动文件
	-i: interactive 如果目标存在会提示是否覆盖
	-f: force 强制移动。
	-t: target 指定目标，这样就可以先指定目标了。
du: 计算文件使用的空间大小,如果对象是目录，则递归显示所有的目录的大小，但不显示文件。是磁盘使用空间，而不是实际文件大小。
	-0:不再一行一个文件，都放在一行输出
	-a:不止计算输出目录，还计算输出文件的大小
	-c:  附加输出一个总的大小
	-s:  只输出一个总的大小
	-d:  eg:d0 d1 等 输出第几层的目录。d0 相当于-s参数。
	-h:  human-readable 自动单位换算

install: 复制文件并且指定属性,默认把一个文件复制到一个地方，并会加上执行权限,源必须是文件，不能是目录，也就是只能install文件。
	-d:  directory 创建目录
	-m:  mode 指定权限
	-t:  target 指定目标目录
read: 从标准输入或者文件描述符读取数据的一个bashshell内建命令，并且把输入的文字按照指定的分隔符进行分开。默认分隔符为换行符, 如果最后提供一个变量名，则会把读取的字符存储到该变量中。
	-p:prompt 可以输入一些提示语言 eg:read -p -d\ "please input your name:" NAME SEX AGE && echo -e "hello! $NAME, You are a $SEX. Today you ae $AGE years old"
	-d:分隔符  紧跟着-d的第一个字符 上例中的\ 表示以空格为分隔符
	-t:后跟等待秒数 , 会等待指定的秒数，没有输入立即返回
file：查看文件内容类型的。

	
#文本处理(记住常用的！！！)
文本查看
cat ：concatenate 连接并显示,可以加多个文件。默认是标准输入读，然后输出到标准输出。
	-n:显示行号。行号不是文件内容。
	-E:show ends 显示每一行的结束符，linux是$ window是$\n ??
	-A:show ALL  显示所有的字符，包括制表符，空格等。
tac ：反向输出。
more :支持向后翻页查看。空格向后翻页，b在没有翻页到尾部的时候向前翻。到最后自动退出
less :就是查看man手册的命令，可以向后，向前翻，并且不会自动退出。想退出敲q
head :查看文件的前n行,空白行也是一行
	 -n:显示多少行，默认为10
tail :查看文件的后n行，空白行也是一行
	 -n:显示多少行，默认为10
	 -f:查看文件并不退出，等更新就显示
文本处理：
cut  :剪切并显示指定字段,并不会影响源文件，只是影响显示次序。
	 -d：指定字段分隔符，默认是空格 -d:
	 -f: filed 指定要显示的字段 eg:-f1 显示第一个字段 -f1,3 显示一三字段 -f1-3显示一到三字段
join :很少用
sed  :
awk	 : 
grep : global research :根据某种模式，去搜索文本，并将符合模式（pattern）的文本行显示到屏幕上。egrep fgrep rgrep也属于此家族。部分匹配。
	模式就是：由文本字符和正则表达式组成的匹配条件。
	-i: ignore-case 忽略大小写
	--color: 把匹配的串用颜色显示出来。
	-v: --invert-match 显示没有被模式匹配到的行。
	-o: 只显示被模式匹配的字符串，而不是这一行，每个串显示一行。
	
正则表达式：REGEXP(regular expression) 由不保存其本身意义的字符的元字符组成。工作在贪婪模式下，尽可能长的匹配。
常用元字符：
.:匹配任意单个字符
.*:任意长度的任意字符
字符匹配次数的字符
	*:匹配其前面的字符任意次 eg:a, b, ab , aab, acb, adb, annb, :grep a*b   得：b, aab
	\？：匹配其前面的字符1次或0次 a?b则表示ab 或b （注意其是行内部分匹配，而不是全部匹配）
	\{m,n\}:匹配其前的字符至少m次，至多n次。

位置铆定：
^:铆定行首，此字符后面的任意内容，必须出现在行首。
$:铆定行尾，此字符前面的任意内用，必须出现在行尾。

sort : 排序输出，默认根据字符在ASCII码中的次序升序排序。
	 -n:按照数值的大小进行排序。
	 -r:reverse 反向排序输出。
	 -t:指定字段分隔符
	 -k:指定以哪个字段排序 eg: sort -t: -k3 -n /etc/passwd  指定分割符号为： 第三个字段为比较字段， -n 为数值比较。
	 -u:uniq 排序后相同的行只显示一次。
	 -f:忽略字符大小写
uniq: 报告或者忽略重复的行，所谓重复的行，是相邻的相同的行，如果不相邻，则不算重复的行。
	-d:只显示重复的行 
	-D:显示所有的重复的行，如果这个行重复三次就显示三次。
	-c:显示某一行重复的次数，会显示所有的行，

wc: word count 文本统计，可以统计
	无：行数，单词数，字节数，位数，最大行长度。
	-l：只显示行数
	-w:单词数
	-c:字节数
	-m:字符数
	-L:最长的一行包含多少个字符
	
tr:字处理命令，用于实现转换或删除字符，<输入重定向
	eg: tr "ab" "xc" </etc/passwd 并不改变文件内容，使用输入重定向，读入文件内容，然后逐个字符处理，见到a就换成x, 见到b就换成c
	-d：delete eg:tr -d "abc" 见到，a|b|c就删除，
	
#目录管理
ls
cd
pwd
mkdir: make directory 创建空目录
	  -p: parent 会创建不存在的父目录
	  -v: verbose 详细信息，显示创建过程。
  eg: mkdir -pv /mnt/test/{x/m,y} 将会创建 /mnt/test/x/m 和/mnt/test/y目录, 使用到了花括号展开。
  	  mkdir -pv {a,b}_{c,d} 将创建a_c, a_d, b_c, bd文件
	  
rmdir: remove directory 删除空目录
	  -p: parent 删除一脉单传的文件夹。
   eg:rmdir -p /home/hu/hhh
tree: 查看文件系统树

运行程序
设备管理
软件管理
进程管理
网络管理

linux 系统启动流程：
1、power on OR restart
	进入启动流程的两种方式，一个是计算机在关机状态下，按下电源按钮，开始启动。另一个就是计算机处于用户登录状态，然后用户重启，系统先关机，然后进入启动。
2、BIOS
    BIOS是basic input output system的缩写，译为基本输入输出系统，计算机启动第一个读取并运行的程序。 大家知道CPU是从内存中读取运行操作系统和应用程序的，
但是内存属于RAM(Random Access Memory)随机访问存储器，是断电就会失去数据的。而ROM(Read only memory)只读存储器，是掉电不丢失数据的存储器。所以在计算机设计的时候，
在一个ROM中刷入了第一个运行程序，就是BIOS。计算机上电后，CPU会自动读取并运行ROM中的BIOS程序。BIOS功能主要分为如下两部分：
2.1 POST（power on self test）上电自检
	BIOS第一步先进行上电自检，就是检查所有的硬件，如果发现硬件有故障或错误，主板上的蜂鸣器将会发出不同的声响来提示用户不同的错误。如果没有故障，将会进入下一步，读取启动序列(boot squence)。
2.2 Read Boot Squence  读启动序列
    启动序列是所有可能启动的设备的列表序列，是可以修改的。例如我们用U盘安装系统的时候，要从U盘启动，这时候就要进入BIOS,然后设置U盘为启动序列的第一项。BIOS会根据现在的启动序列，
依次读取该启动序列中包含的不同的设备，并读取第一个扇区（512bytes）,然后通过判断扇区的第511和512字节是不是分别为0x55和0x11标志，如果是，则把运行交给该设备，并从第一个扇区开始读取并运行。
而这第一个扇区就是所谓的MBR.

3、MBR(Main boot record)
	进入该阶段说明已经选择好了启动的设备，BIOS运行结束，那么MBR是什么呢？首先MBR必须包含一段程序，当BIOS运行结束的时候，会把找到的MBR加载如内存，然后CPU开始运行，下面是MBR512字节
所包含的信息：
	0～445：		共446字节		代码区		代码用来检查分区表完整性和类别，并把控制权交给活动分区(分区表的每一部分的第一个字节如果为0X80)。
	446～509：	共64字节		分区表		分区表分为四部分，每部分16字节。每部分表示一个一级分区，所以每块硬盘最多分四个一级分区。
	510～511：	共2字节		MBR标志	 0x55和0xAA主引导记录标志，BIOS用来判断设备是否可以启动。
每个主分区的16个字节分配：			
	0：			共1字节	     标志区	 	 	 如果是0x80则表示该分区为激活的，将把控制权交给此分区，四个一级分区中，只有一个是激活的。
	1～3：	   共3字节			分区地址			这3个字节，表示该分区表所表示的分区的位置，包括柱面，磁头，扇区号等等。
	4：			共1字节		 分区的类型  		主分区，扩展分区，逻辑分区。逻辑分区在扩展分区里进行划分，扩展分区可以有0到1个，主分区可以有0到4个，但是主分区数+扩展分区数=4,逻辑分区数量无限制
	5～7：		共3字节		分区最后扇区物理位置  
	8～11：       共4字节   		分区第一扇区逻辑地址
	12～15		 共4字节		 分区的扇区总数        所以最大扇区数为2的32次方，按扇区512bytes,所以单个分区最大不超过2TB,考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大不能超过2TB

CPU运行加载到内存的MBR程序，检查分区表，并检索到可以用来启动的分区（激活分区/启动分区）， 或者bootloader,然后把控制权交给该分区或者bootloader。

4、硬盘启动
MBR之后就代表CPU已经找到硬盘上可以启动的分区或者预先安装好的bootloader程序，接下来有两种方式：
4.1 启动分区启动
	读取启动分区的第一个扇区，叫做卷引导记录（VBR-volume boot record）。该扇区里的程序会告诉CPU操作系统在哪里，然后计算机就开始加载操作系统了。
4.2 bootloader 启动
	启动分区中找到bootloader 启动加载程序。最常用的bootloader 是GRUB. 这种方式启动，会弹出界面让用户选择操作系统，或者内核版本，多用于一个硬盘安装多个系统的情况。

5、内核加载
硬盘启动之后，CPU就找到了操作系统的位置，首先加载/boot下的内核。然后加载init进程。设置运行级别。加载开机启动程序。 用户登录程序。 进入loginshell。启动完毕。

#常用的自由软件开源协定：GPL, BSD, Apache
#www.kernel.org linux内核网站。
#内核 + 库 + 应用软件
常用发行版与内核的关系：
suci
debian
	ubuntu mint 
redhat
	centos mandriver 
编译是和硬件平台密切相关的。
LFS linux from scratch: 一步一步的构建一个linux
技术人员的发展道路：
1、找方向，定目标：昨日西风凋碧树，独上高楼，望尽天涯路：3天 浅尝辄止？
2、孜孜不倦，两三年：衣带渐宽终不悔，为伊消得人憔悴：2年  专家
3、忽然发现，已经完成目标：众里寻他千百度，那人却在灯火阑珊处：5年 权威

#数据管理软件：mysql orcal...

进程：在每个进程看来，当前主机上只有内核和当前进程。进程是程序的副本，是程序执行的实例，有生命周期。
#bash shell及其特性：man bash
1、每个用户可以登录多次，也会获得多个不同的shell。工作环境可以设置不相同。属于不同的进程。shell中可以再打开shell,这是父子shell。环境设定就发生变化了。
2、命令历史
上下箭头调出最近使用的命令
history: 查看最近使用的命令
		-c: 清空整个命令历史
		-d: m [n] 从第几条开始，删除几条。 eg:history -d 500 2 从第500条开始删除2条
		-w: 将缓冲区的命令历史，至历史文件～/.bash_history
使用技巧:
		!441  执行命令历史中的第441条命令
	    ！-n  执行命令历史中倒数第几条命令
		!!    执行上一条命令
		！string 执行命令历史中，以指定字符串开头的命令
		！$    引用前一个命令的最后一个参数 也可以用 ESC松开然后 . 或者 Alt + .
		

3、命令别名
alias cmd_alias='command  option argument' , 这种方式定义的别名，只在shell的生命周期有效，即有效范围在当前shell进程。若想让其永久有效，就必须把这些参数写到bash的配置文件中。
alias 显示系统上定义的所有别名
unalias +撤销别名 eg: unalias cls
\command 使用命令本身，而不是别名

4、命令行编辑
ctrl + a: 光标跳转到命令行首
ctrl + e: 光标跳转到命令行尾
ctrl + k: 删除光标到命令行尾的内容
ctrl + u: 删除光标到命令行首的内容
ctrl + d: 从光标开始，向后一个一个字符的删除
ctrl + l: 清屏
5、命令行展开
6、文件名通配(globbing)
*:	匹配任意长度的任意字符,没长度也可以
?:	匹配任意单个字符
[]:	指定范围内的任意单个字符[abc] [a-z] [A-Z] [a-zA-Z]
	[[:space:]] 所有的空白字符
	[:punct:]	标点符号集合
	[:lower:]   小写字母
	[:upper:]	大写字母
	[:alpha:]	大小写字母
	[:digit:]	数字	
	[:alnum:]	数字和大小写字母
eg:[[:alpha:]]*[[:space:]]*[[:alpha:]] 以字母开头，字母结尾，中间有空白字符的文件名。 创建空白字符文件， touch 'a b'
man 7 glob 可以获得上述集合列表
[^]:	匹配指定范围外的任意单个字符 [^0-9]

7、管道，重定向 < << > >>
					  描述符
 标准输入：stdin 		0			键盘
 标准输出：stdout    	1			显示屏
 标准错误输出：stderr 	   2		   显示屏
 
 系统为什么要设置标准输入，标准输出，标准错误输出呢？
 IO重定向是什么呢？
 
 输出重定向： >(覆盖输出) >>(追加输出)
 输入重定向：  <() <<()
 
 输出重定向
 > >>重定向标准输出
 set -C 禁止覆盖输出到一个已经存在的文件
 	 +C 关闭此功能
     >| 在-C 情况情况下，强制输出

 2> 2>>重定向错误输出
 
 &>: 重定向标准输出或错误输出到同一个文件 不存在&>>
 
 输入重定向
 <:输入重定向
 <<:here document 生成文档 eg: cat << end(文档结束标志)  eg: cat >> test.c << eof
 
 管道
 command1 | command2 将前一个命令的输出作为后一个命令的输入，这是命令管道
 
 tee 从标准输入读取内容，保存到文件一份，显示到屏幕一份
 
8、变量
PATH:命令搜索路径变量
HISTSIZE:命令历史大小,默认为1000个
9、编程（脚本）
10、命令补全和路径补全
命令补全是根据PATH环境变量查找进行补全的，而路径补全是根据输入的打头的路径推断的。都是使用tab按键进行补全操作。

11、命令替换$(command)  或者 `command`
把命令中的某个子命令替换为其执行结果的过程。
eg: ls $(pwd)
eg: touch file-$(date +%F-%H-%M-%S).txt
eg: touch file-`date +%F-%H-%M-%S`.txt

12:bash支持的引号说明
``：命令替换
“”：弱引用，可以实现变量替换。
‘’：强引用，不完成变量替换
pstree:

#资源的用户和权限：
1、在linux中，每一个资源都会标志出三种权限，用户权限，用户组权限，第三方权限。
2、对计算机而言用户和组都是标识符，用来获取资源的权限。
3、在用户登录之后，用户一般通过执行不同的程序，产生不同的进程，通过进程来操作计算机，完成相应的任务。
4、在计算机中，不只文件有属主和属组。进程也有属组和属主。谁发起的进程，进程就以谁的身份去运行。
5、当一个进程运行时，访问到文件时候，内核会检查进程的属主的权限，这就是进程的安全上下文。
总结：用户在使用计算机的时候，是通过调用不同的程序，产生不同的进程，而完成相应的任务的。那么进程就是用户使用计算机的代理，
所以进程就是以其调用者的身份运行的，当进程访问资源时，内核会检查进程调用者的权限和资源的权限，然后判断出，进程对该资源的
权限。这就是进程的安全上下文。若进程的调用者，既不属于资源的属组，也不属于资源的属主，那么就只能以第三方的权限进行访问该文件了。
6、文件权限：r: 可读 w：可以编辑或删除  x：exacutable 可执行，可以在命令提示符下当作命令，进行运行。
   目录权限：r:可以用ls   w：可以在此目录中创建文件  x: 可以使用cd 和 ls -l     一般情况下目录都有x权限，而文件不能有。
   也可以用8进制来进行表示文件权限: 755: rwxr-xr-x
7、在系统上，用户和组都是使用id进行识别的，即uid 和 gid ，将用户名转化为id号的数据库为/etc/passwd, 将用户组转化为组id的数据库是/etc/group
/etc/passwd : 用户名和登录所打开的shell类型。
/etc/shadow :用户密码
/etc/gshadow:组密码，作用

8、用户类别
大体上：管理员0和普通用户[1-65535]
普通用户：系统用户[1-499]，一般用户[500-60000]
系统用户：由于在计算机中，每一个进程运行都要有用户来执行，专门用来运行一些用户登录之前的服务，后台进程的用户，一般禁止登录系统。

9、用户组类别
管理员组：
普通组：
	普通组：
	一般组：

另一种分类
	基本组（默认组）：创建文件的默认组
	私有组：创建用户时，如果没有指定默认组，那么就创建一个与用户名相同并且只包含用户本身的组。指定该组为默认组。基本组不一定是私有组。
	附加组：默认组以外的组。

10、进程访问文件的权限判断过程：
先获得进程的运行者id，获得文件的属组，和属主，对比该进程运行者是不是该文件的属主，是则以属主权限访问，否则继续判断进程运行者是不是属于该文件的属组，
是则以属组权限运行，否则以第三方权限运行。

11、man 5 passwd
accunt：passwd：UID：GID：comment：homedir：shell
用户名：密码占位符：用户id：用户默认组ID：
合法shell：/etc/shells 文件中出现的shell,才可以被用来作为

12、man 5 shadow
accunt:encrypted passwd:上次修改密码距离1970年1月1号的天数:密码最短使用期限：密码最长使用期限：密码离过期之前多少天开始提醒：宽限期限，必须改，不改锁定：明确指定使用多少天：保留
若密码项前有！！，表示该用户是锁定的，不允许登录的。

13、加密方法
	对称加密：加密和解密使用同一个密码
	公钥加密：密码成对出现，一个公钥（public key），一个私钥(secret key)。公钥加密，私钥解密。
	单项加密：散列加密，能加密不能解密。用来提取数据特征码。用于数据完整性校验。
		1、蝴蝶效应：初始条件的微小变化，将引起结果的巨大变化。防止逆向工程，防止解密。
		2、定长输出。
		常用:MD5:message digest 128位定长输出  5 is version
			SHA1：secure hash algorithm 160位定长输出
	
14、useradd USERNAME 增加用户
/etc/default/useradd: useradd 的配置文件

15、passwd USERNAME	修改密码

16、/etc/group 文件格式说明
组名：密码：组id：以此组为附加组的用户名

17、groupadd GROUPNAME

18、与用户管理相关的命令：
	useradd, userdel, usermod, passwd, chsh, chfn, finger, id, chage
useradd [optiongs] USERNAME
		-u UID 指定UID
		-g GID 指定基本组的GID 或者 组名，组必须事先存在
		-G GID... 指定附加组，组必须事先存在,如果有多个要用,号隔开
		-c "comment" 指定用户的注释信息
		-d /path/to/somedirectory 指定家目录
		-s 指定shell的路径， 一定是/etc/shells文件里的某一行
		-m 强制给用户创建家目录，-k 复制/etc/skel里面的文件到家目录，和-m一起使用,
		-M 不给用户创建家目录，就算/etc/login.defs说应该默认要创建，也不创建。
		-r 添加一个系统用户，不会创建家目录 id号<500
usedel [options] USERNAME 
		无: 不会删除家目录
		-r: 删除用户的同时，同时删除的家目录
		
usermod [options] USERNAME
修改用户信息.
		-u UID
		-g 基本组ID
		-G 修改附加组，会覆盖之前的附加组，-a 追加附加组，不覆盖。
		-c 指定注释
		-d 修改家目录， -m 会把当前家目录中的文件，移动到新的家目录中。
		-s 修改默认shell
		-l 修改登录名
		-e 指定过期时间
		-f 非活动时间
		-L 锁定帐号
		-U 解锁
chsh USERNAME
交互命令，专门用来修改用户的shell的。

chfn USERNAME
修改用户的注释信息(comments info)，finger

passwd [option] [USERNAME]
普通用户只能修改自身密码，即passwd
管理员用户可以修改其他用户密码即passwd USERNAME
	--stdin 表示从标准输入读入密码，可以配合管道，使用，在脚本中自动创建用户并指定密码
	-l lock
	-u unlock
	-d 删除用户密码,红帽上禁止空密码用户登录

pwck	
检查用户帐号完整性。
	
id [options] [USERNAME] 
用来查看用户的帐号属性信息。
		-无  
		-u 用户id
		-g 默认组id
		-G 所有的组id
		-n name 显示name 而不是id
		
chage [options] LOGIN
修改用户密码逾期时间的。
		-d:	最近一次的修改时间
		-r:	过期时间
		-T:	非活动时间
		-m:	最短使用期限
		-M:	最长使用期限
		-W:	警告时间

finger USERNAME
查看用户帐号信息。
19、组管理相关的命令：
	groupadd, groupdel, groupmod, gpasswd

groupadd [options] GROUPNAME 
		-g: 指定GID
		-r: 添加一个系统组
groupmod [optiongs] GROUPNAME
		-g: 修改组id 
		-n: 修改组名
		
groupdel GROUPNAME
删除用户

gpasswd
为组设置密码。密码的作用是，别的用户可以临时登录为其基本组。

newgrp 
登录到一个新组作为基本组。exit 用来退出，如果该组不属于用户的附加组，则需要改组的组密码。

#添加一个用户会修改什么文件：
  passwd, shadow, group 中各添加一行。
20、权限管理的命令：
chmod, umask

chown [OPTION]... [OWNER][:[GROUP]] FILE...
只有管理员才能改变文件属主。
	-R：--recursive 修改目录及其内部文件的属主，属组
	--reference=RFILE 设置属主属组和RFILE文件的一样
eg: chown hu /hu/jj  改变/hu/jj文件的属主的为hu
	chown hu:hu /hu/jj 同时修改/hu/jj文件的属主和属组
	chown :hu /hu/jj 修改文件的属组

chgrp [OPTION]... GROUP FILE...
只有管理员才能使用此命令,修改文件的属组。
	-R：--recursive 修改目录及其内部文件的属组
	--reference=RFILE 设置属组和RFILE文件的权限一样
	
chmod [OPTION]... MODE[,MODE]... FILE...
修改文件权限。
			-R: 修改目录及其内部文件的权限
			--reference=RFILE 设置属主属组和RFILE文件的权限一样

			
修改三类： chmod 750 file ，利用八进制，一次性修改三类权限，如果没给全，例如75 则按照075来算，5按照，005来算
修改某类用户某位，某些位权限： u g o a  =  + -  eg:chmod u=rwx /tmp/abc  ; chmod o=rx /tmp/abc ; chmod g=r,u=x /tmp/abc; chmod go=r /tmp/abc; chmod a=x /tmp/abc;
				eg: chmod u+x /tmp/abc ; chmod -x /tmp/abc; chmod u+x, g-x /tmp/abc; chmod a+x /tmp/abc; chmod +x /tmp/abc; chmod -x /tmp/abc
				chmod u-wx /tmp/abc 
	

umask 创建文件或目录的遮罩码，掩码， eg：umask 002 设置用户的掩码  这时候创建目录权限则为775 ，创建文件权限则为664
777 -umask 创建目录
666 -umask 创建文件，因为文件在linux中默认没有执行权限,所以创建的时候，如果计算的结果有执行权限，则加1， 并且6-7等于零 不等于-1

#用户登录
用户的角度来讲，shell的类型分为：登录式shell 和 非登录式shell
登录式shell:正常通过某终端登录的shell，或通过su - username ; su -l username
非登录式shell：su username, 图形终端中，打开的终端，自动执行的shell脚本

bashshell 配置文件：全局配置和个人配置
全局配置（每个用户都有效）：/etc/profile; /etc/profile.d/*.ssh ;/etc/bashrc
个人配置(当前用户有效)：~/.bash_profile ~/.bashrc， 如果全局的和个人的不一样，按个人的。作用范围越小，越生效。
profile:开机设置环境变量，或运行变量或脚本。
.bashrc:设置本地变量，定义命令别名

登录式shell如何读取配置文件：
/etc/profile-->/etc/profile.d/*sh--->~/.bash_profile----> ~/.bashrc --->/etc/.bashrc

非登录式shell如何读取配置文件：
~/.bashrc --->/etc/bashrc--->/etc/profile.d/*sh

所以su username 和 su - username 前者叫不完全切换，后者叫完全切换


#配置文件
/etc/login.defs ：密码的警告时间，最短密码长度，默认要不要创建家目录，用户密码使用什么方式加密，删除用户时候的设定等
		
#职业study目标#
语言： 熟练使用C、C++、python、shell脚本、SQL查询语言
框架： QT、gstreamer、tensorflow
环境： linux, windows, android
工具： vim、wireshark、cmake、gdb、
库：	 glib、opencv、
其他：	TCP/IP网络协议、plugin编写、建立自己的功能代码库，并上传github。

第一课：IO 与 IO 重定向
stdin  	0
stdout	1
stderr	2	

> 覆盖输出
>> 追加输出

		
		
		
		
		

