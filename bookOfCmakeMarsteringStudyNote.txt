CMake 学习笔记

一：写在前面的话
1.1 为什么要学cmake?
大型C/C++项目都是由cmake来做构建管理器，了解cmake,对了解整个项目的框架很有帮助，而框架对了解一个大型程序的重要
性不言而喻。
1.2 达到什么样的学习目标？
理解cmake的工作机制，能读懂大型程序的CMakeLists.txt，会写CMakeLists.txt,学习到最后要读懂mediapipe的CMakeList.txt
还有C++的标准库的CMakeLists.txt
1.3 怎样学？
以经典书籍，Mastering+CMake为参考，边读边做笔记边对着项目看。
看完整本书籍之后，用自己的语言组织起来写专题博客。
1.4 学习计划
每一个星期至少学6个番茄闹钟的时间的CMake.
1.5 学习打卡
2019/5/26 

二：笔记开始
日期：2019/5/26（2）
cmake 是一个用C++编写的跨平台的构建管理器（build manager），通过解析用户编写的CMakeLists.txt生成不同平台所需要的构建文件
如linux平台的Makefile.其比老一代的autoconf有很多优势。
2.3 cmake的基础用法和语法
cmake控制的构建过程是由编写CMakeLists.txt文件而完成的，每一个相关的文件夹下都需要有一个CMakeLists.txt文件，
这些文件由cmake的一些简单命令组成，命令的形式是command(args...), command是命令的名字，args是由空白字符分割开
的参数列表。版本2.2及以后的cmake命令名可以用大写也可以用小写.
cmake 支持简单的变量，可以包含字符串或字符串列表，引用变量使用${VAR}的形式。
cmake 可以直接访问系统的环境变量，语法为：$ENV{VAR} 例如：$ENV{HOME}
2.4 helloword sample
简单版本：
project(Hello)
add_executable(hello hello.c)
解释：project 注册一个项目名，add_executable表示用什么源文件生成目标文件，以及生成的目标文件的名字，
项目名和目标名是没有关系的，可以写成不一样的值。

日期：2019/5/27(0.2)
复杂版本：
cmake_minimum_requied(2.6)
project(Hello)

set(HELLO_SRC hello.c file2.c file3.c)
if(WIN32)
	set(HELLO_SRC ${HELLO_SRC} WinSupport.c)
else
	set(HELLO_SRC ${HELLO_SRC} UnixSupport.c)
endif()

add_executable(hello ${HELLO_SRC})

#look for the tcl library
find_library (TCL_LIBRARY 
NAMES tcl tcl84 tcl83
PATHS /usr/lib /usr/local/lib
)

if(TCL_LIBRARY)
	target_link_library(hello ${TCL_LIBRARY})
endif()

解释:set 可以用来设置变量，这里设置了一个string列表，后面又根据不同平台追加了不同的支持文件。
#开头的是注释，将被cmake忽略。find_library命令查找库，给了查找的名字，以及查找的路径。

日期：2019/05/28
2.5 运行cmake
cmake既支持内部编译也支持外部编译;
内部编译就是在源文件夹下进行编译，这样编译产生的文件就会在源文件夹下，比较乱，有删除源文件的风险。
外部编译就是专门建立一个文件夹，然后在这个文件夹下进行编译。

cmake 还有ccmake cmake-gui cmake -i(交互模式新版本已经不支持)等模式,交互式的形式进行配置,一般大项目用交互式比较方便.
cmake 在用参数的时候要用-D标志如-DCMAKE_BUILD_TYPE指定编译的类型.
为cmake指定编译器的方法：1.直接指定-DCMAKE_CXX_COMPILER -DCMAKE_C_COMPILE 命令行参数 2.设置环境变量 export CC=/usr/gcc CXX=/usr/g++ 
为指定编译器或链接器指定参数：LDFLAGS CXXFLAGS CFLAGS 分别指定链接器和C++和C编译器的参数.

查看项目的依赖信息：
用cmake作为构建管理器的项目,当用cmake初始化之后,会在每一个生成目标文件的地方生成如下四个文件,这四个文件用于记录项目的依赖以及更新.
depend.make	:存储了每一个.o文件依赖的文件的信息
flags.make	:包含了用于文件的编译选项
build.make	:构建规则
DependInfo.make	:依赖库信息

由于cmake兼顾更新依赖的任务，所以在运行cmake产生的Makefile时候,必须能随时运行cmake.

第三章 主要概念
3.1 cmake的主要结构
cmake主要的概念有目标文件(target),生成器(generator),命令(command);这些概念都是使用C++的类实现的,并被命令引用.
cmake的管理对象是源文件,由源文件生成目标文件.目标文件就是可执行文件或库.源文件会分为不同的目录,只要用于生成目标文件的目标文件夹都会包含一个CMakeLists.txt的文件,
cmake的在工作的时候会在每个目录下产生一个生成器,称为本地生成器,用于生成Makefile和项目文件,多个本地生成器共享一个全局生成器,全局生成器会被cmake调用用于操控整个
生成工程.
cmake运行机制：
cmake执行的时候会先生成一个cmake类对象实例,这个实例会管理整个配置过程,以及盛放所有的构建信息,如缓存值等. cmake做的第一件事是根据用户的选择来创建一个全局生成器,是Unix的
Makefile，还是visual studio 10.然后cmake 会把控制权交给这个全局生成器.
全局生成器负责项目的配置和Makefile的生成,在生成Unix的Makefile的过程中,全局生成器会为每一个源文件中的参加编译的子文件夹生成一个本地生成器,本地生成器会生成本文件夹下的Makefile
全局生成器只负责协调这些由本地生成器生成的Makefile,
3.2 目标文件
3.3 源文件
3.4 目录,生成器,测试,属性
3.5 变量和缓存
3.6 构建配置










